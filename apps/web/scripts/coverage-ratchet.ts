#!/usr/bin/env node
/**
 * Coverage Ratchet Script
 *
 * Ensures code coverage never decreases from the baseline.
 * Reads coverage from coverage/coverage-summary.json (generated by vitest --coverage)
 * Compares against .coverage/baseline.json
 *
 * Usage:
 *   pnpm run test:coverage:ratchet    # Check against baseline
 *   pnpm run test:coverage:update     # Update baseline to current
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { dirname } from 'path';

interface CoverageMetrics {
  lines: number;
  functions: number;
  branches: number;
  statements: number;
}

interface BaselineFile {
  version: string;
  timestamp: string;
  coverage: CoverageMetrics;
}

const COVERAGE_PATH = './coverage/coverage-summary.json';
const BASELINE_PATH = './.coverage/baseline.json';
const THRESHOLD = 0.01; // Allow 0.01% tolerance for floating point

function readCurrentCoverage(): CoverageMetrics {
  if (!existsSync(COVERAGE_PATH)) {
    console.error(`‚ùå Coverage file not found: ${COVERAGE_PATH}`);
    console.error('   Run "pnpm run test:coverage" first');
    process.exit(1);
  }

  const summary = JSON.parse(readFileSync(COVERAGE_PATH, 'utf-8'));
  const total = summary.total;

  return {
    lines: total.lines.pct,
    functions: total.functions.pct,
    branches: total.branches.pct,
    statements: total.statements.pct,
  };
}

function readBaseline(): CoverageMetrics | null {
  if (!existsSync(BASELINE_PATH)) {
    return null;
  }
  const baseline: BaselineFile = JSON.parse(readFileSync(BASELINE_PATH, 'utf-8'));
  return baseline.coverage;
}

function writeBaseline(coverage: CoverageMetrics): void {
  const dir = dirname(BASELINE_PATH);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  const baseline: BaselineFile = {
    version: '1.0.0',
    timestamp: new Date().toISOString(),
    coverage,
  };

  writeFileSync(BASELINE_PATH, JSON.stringify(baseline, null, 2) + '\n');
}

function formatCoverage(metrics: CoverageMetrics): string {
  return `lines: ${metrics.lines.toFixed(2)}%, ` +
         `functions: ${metrics.functions.toFixed(2)}%, ` +
         `branches: ${metrics.branches.toFixed(2)}%, ` +
         `statements: ${metrics.statements.toFixed(2)}%`;
}

function compareCoverage(current: CoverageMetrics, baseline: CoverageMetrics): string[] {
  const failures: string[] = [];

  const metrics: (keyof CoverageMetrics)[] = ['lines', 'functions', 'branches', 'statements'];

  for (const metric of metrics) {
    const diff = current[metric] - baseline[metric];
    if (diff < -THRESHOLD) {
      failures.push(`${metric}: ${baseline[metric].toFixed(2)}% ‚Üí ${current[metric].toFixed(2)}% (${diff.toFixed(2)}%)`);
    }
  }

  return failures;
}

function main(): void {
  const args = process.argv.slice(2);
  const command = args[0] || 'check';

  if (command === 'update') {
    const current = readCurrentCoverage();
    writeBaseline(current);
    console.log('‚úÖ Coverage baseline updated');
    console.log(`   ${formatCoverage(current)}`);
    process.exit(0);
  }

  // Check mode (default)
  const current = readCurrentCoverage();
  const baseline = readBaseline();

  if (!baseline) {
    console.log('‚ö†Ô∏è  No baseline found. Creating initial baseline...');
    writeBaseline(current);
    console.log('‚úÖ Baseline created');
    console.log(`   ${formatCoverage(current)}`);
    process.exit(0);
  }

  console.log('üìä Coverage Comparison');
  console.log(`   Current:  ${formatCoverage(current)}`);
  console.log(`   Baseline: ${formatCoverage(baseline)}`);

  const failures = compareCoverage(current, baseline);

  if (failures.length > 0) {
    console.error('\n‚ùå Coverage regression detected:');
    for (const failure of failures) {
      console.error(`   ‚Ä¢ ${failure}`);
    }
    console.error('\nTo update baseline (if intentional):');
    console.error('   pnpm run test:coverage:update');
    process.exit(1);
  }

  // Check if coverage improved
  const improved = compareCoverage(baseline, current);
  if (improved.length > 0) {
    console.log('\n‚úÖ Coverage improved! Updating baseline...');
    writeBaseline(current);
    for (const imp of improved) {
      console.log(`   ‚Ä¢ ${imp}`);
    }
  } else {
    console.log('\n‚úÖ Coverage meets baseline');
  }

  process.exit(0);
}

main();
