#!/usr/bin/env python3
"""
Generate optimized Dockerfiles for various project types.

Usage:
    python generate-dockerfile.py --type python --output .
    python generate-dockerfile.py --type node --port 3000 --output .

Types: python, node, nextjs, go
"""

import argparse
import sys
from pathlib import Path


PYTHON_DOCKERFILE = '''# Multi-stage build for Python application
# Generated by containerization skill

# Stage 1: Build dependencies
FROM python:{python_version}-slim as builder

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# Stage 2: Runtime
FROM python:{python_version}-slim

# Create non-root user
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

WORKDIR /app

# Copy dependencies from builder
COPY --from=builder /root/.local /home/appuser/.local
ENV PATH=/home/appuser/.local/bin:$PATH

# Copy application code
COPY . .

# Change ownership
RUN chown -R appuser:appgroup /app
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:{port}/health')" || exit 1

EXPOSE {port}

CMD [{cmd}]
'''


NODE_DOCKERFILE = '''# Multi-stage build for Node.js application
# Generated by containerization skill

# Stage 1: Dependencies
FROM node:{node_version}-alpine AS deps

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Stage 2: Production
FROM node:{node_version}-alpine AS runner

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

WORKDIR /app

# Copy dependencies
COPY --from=deps /app/node_modules ./node_modules

# Copy application code
COPY . .

# Change ownership
RUN chown -R nodejs:nodejs /app
USER nodejs

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
    CMD wget --no-verbose --tries=1 --spider http://localhost:{port}/health || exit 1

EXPOSE {port}

CMD [{cmd}]
'''


NEXTJS_DOCKERFILE = '''# Multi-stage build for Next.js application
# Generated by containerization skill

# Stage 1: Dependencies
FROM node:{node_version}-alpine AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package*.json ./
RUN npm ci

# Stage 2: Build
FROM node:{node_version}-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Build application
RUN npm run build

# Stage 3: Production
FROM node:{node_version}-alpine AS runner
WORKDIR /app

ENV NODE_ENV=production

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# Copy built application
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

USER nextjs

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
    CMD wget --no-verbose --tries=1 --spider http://localhost:{port}/api/health || exit 1

EXPOSE {port}

ENV PORT={port}

CMD ["node", "server.js"]
'''


GO_DOCKERFILE = '''# Multi-stage build for Go application
# Generated by containerization skill

# Stage 1: Build
FROM golang:{go_version}-alpine AS builder

WORKDIR /app

# Install git for fetching dependencies
RUN apk add --no-cache git

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build binary
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Stage 2: Runtime (minimal)
FROM gcr.io/distroless/static:nonroot

WORKDIR /

# Copy binary from builder
COPY --from=builder /app/main .

# Use nonroot user (65532:65532 in distroless)
USER 65532:65532

EXPOSE {port}

CMD ["/main"]
'''


def generate_dockerfile(project_type: str, port: int, output_dir: str, **kwargs):
    """Generate Dockerfile for specified project type."""
    
    templates = {
        'python': (PYTHON_DOCKERFILE, {'python_version': kwargs.get('python_version', '3.11'), 'cmd': kwargs.get('cmd', '"python", "main.py"')}),        'node': (NODE_DOCKERFILE, {'node_version': kwargs.get('node_version', '20')}),
        'nextjs': (NEXTJS_DOCKERFILE, {'node_version': kwargs.get('node_version', '20')}),
        'go': (GO_DOCKERFILE, {'go_version': kwargs.get('go_version', '1.21')}),
    }
    
    if project_type not in templates:
        print(f"Error: Unknown type '{project_type}'. Use: {', '.join(templates.keys())}")
        sys.exit(1)
    
    template, defaults = templates[project_type]
    params = {**defaults, 'port': port}
    
    dockerfile_content = template.format(**params)
    
    # Write file
    output = Path(output_dir)
    output.mkdir(parents=True, exist_ok=True)
    
    dockerfile_path = output / 'Dockerfile'
    dockerfile_path.write_text(dockerfile_content)
    
    print(f"âœ… Created: {dockerfile_path}")
    
    # Generate .dockerignore
    dockerignore_content = generate_dockerignore(project_type)
    dockerignore_path = output / '.dockerignore'
    dockerignore_path.write_text(dockerignore_content)
    print(f"âœ… Created: {dockerignore_path}")
    
    print(f"\nðŸŽ‰ Generated Dockerfile for '{project_type}'!")
    print(f"\nNext steps:")
    print(f"  1. Review the generated Dockerfile")
    print(f"  2. Build: docker build -t myapp .")
    print(f"  3. Run: docker run -p {port}:{port} myapp")


def generate_dockerignore(project_type: str) -> str:
    """Generate .dockerignore for project type."""
    
    common = '''# Git
.git
.gitignore

# Documentation
README.md
*.md

# Environment
.env
.env.local
.env.*.local

# IDE
.idea
.vscode
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
'''
    
    specific = {
        'python': '''# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv
pip-log.txt
pip-delete-this-directory.txt
.pytest_cache/
.coverage
htmlcov/
.tox/
.mypy_cache/
dist/
build/
*.egg-info/
''',
        'node': '''# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# Testing
coverage/
.nyc_output

# Build outputs (if built in container)
dist/
build/
.next/
''',
        'nextjs': '''# Next.js
node_modules/
.next/
out/

# Testing
coverage/
.nyc_output

# Debug
npm-debug.log*
yarn-debug.log*
.pnpm-debug.log*
''',
        'go': '''# Go
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out
vendor/
'''
    }
    
    return common + specific.get(project_type, '')


def main():
    parser = argparse.ArgumentParser(
        description="Generate optimized Dockerfiles"
    )
    parser.add_argument(
        "--type",
        required=True,
        choices=['python', 'node', 'nextjs', 'go'],
        help="Project type"
    )
    parser.add_argument(
        "--port",
        type=int,
        default=8000,
        help="Port to expose (default: 8000)"
    )
    parser.add_argument(
        "--output",
        default=".",
        help="Output directory (default: current)"
    )
    parser.add_argument(
        "--python-version",
        default="3.11",
        help="Python version (default: 3.11)"
    )
    parser.add_argument(
        "--node-version",
        default="20",
        help="Node.js version (default: 20)"
    )
    parser.add_argument(
        "--go-version",
        default="1.21",
        help="Go version (default: 1.21)"
    )
    
    args = parser.parse_args()
    
    kwargs = {
        'python_version': args.python_version,
        'node_version': args.node_version,
        'go_version': args.go_version,
    }
    
    generate_dockerfile(args.type, args.port, args.output, **kwargs)


if __name__ == "__main__":
    main()
