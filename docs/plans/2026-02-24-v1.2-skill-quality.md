# v1.2 Skill Quality System Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Establish a skill quality system (meta-skill + template) and build 5 new deep skills, with Auth as the reference implementation.

**Architecture:** Three-layer quality system: (1) `skill-depth-standard` meta-skill codifies "what deep means", (2) updated `init_skill.py` template bakes the four mandatory sections into every new skill, (3) five new skills built to this standard with Auth as the gold-standard reference. Validation uses existing `quick_validate.py` + `pnpm test` to confirm nothing regresses.

**Tech Stack:** Markdown (skills), Python (init_skill.py template), TypeScript/Vitest (existing skill validation tests), pnpm workspace.

---

## Task 1: Create `skill-depth-standard` meta-skill

**Files:**

- Create: `.agent/skills/skill-depth-standard/SKILL.md`

**Step 1: Create the SKILL.md**

```markdown
---
name: skill-depth-standard
description: Use when creating or auditing skills to verify they meet Viflo's depth standard. Defines the four failure modes of shallow skills and provides a self-evaluation checklist and Gap Report template for both authors and AI-assisted audits.
---

# Skill Depth Standard

## The Four Failure Modes

Every shallow skill fails in one or more of these ways:

| Failure Mode           | Symptom                                                  | Fix                                                          |
| ---------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| **Abstraction Trap**   | Principles without working code ("use a queue")          | Add `## Implementation Patterns` with runnable examples      |
| **Happy Path Bias**    | No error states, race conditions, or edge inputs covered | Add `## Failure Modes & Edge Cases` section                  |
| **Analysis Paralysis** | Lists options without helping you choose                 | Add `## Decision Matrix` with explicit trade-off reasoning   |
| **Technical Rot**      | No version pinning; patterns may be deprecated           | Add `## Version Context` with last-verified library versions |

## Self-Evaluation Checklist

Run this against any skill before marking it complete:

- [ ] `## Implementation Patterns` — contains working code, not just prose
- [ ] `## Failure Modes & Edge Cases` — covers at least 3 concrete failure scenarios
- [ ] `## Decision Matrix` — when-to-use-X-vs-Y table with explicit reasoning, not just a list
- [ ] `## Version Context` — lists last-verified versions of key libraries/frameworks
- [ ] No section is happy-path-only
- [ ] No "you can use X or Y" without a recommended default and rationale
- [ ] SKILL.md is ≤500 lines (extract to `references/` if needed)

## Gap Report Template

Use this when auditing an existing skill:
```

## Gap Report: [skill-name]

**Audited:** YYYY-MM-DD
**Overall depth score:** [1-4 / 4 failure modes addressed]

### Missing Sections

- [ ] Implementation Patterns
- [ ] Failure Modes & Edge Cases
- [ ] Decision Matrix
- [ ] Version Context

### Failure Mode Analysis

- **Abstraction Trap:** [present / absent — evidence]
- **Happy Path Bias:** [present / absent — evidence]
- **Analysis Paralysis:** [present / absent — evidence]
- **Technical Rot:** [present / absent — evidence]

### Priority

[high / medium / low] — [reason]

```

## Reference Skill

The Auth skill (`.agent/skills/auth-systems/SKILL.md`) is the canonical example of a skill built to this standard. When in doubt, use it as a structural reference.
```

**Step 2: Validate the skill**

```bash
python .agent/skills/skill-creator/scripts/quick_validate.py .agent/skills/skill-depth-standard
```

Expected: `Skill is valid!`

**Step 3: Commit**

```bash
git add .agent/skills/skill-depth-standard/
git commit -m "feat(skill-quality): add skill-depth-standard meta-skill"
```

---

## Task 2: Update `init_skill.py` template with four mandatory sections

**Files:**

- Modify: `.agent/skills/skill-creator/scripts/init_skill.py`

The `SKILL_TEMPLATE` constant currently ends after the structure guidance section. We need to append four mandatory sections to every new skill scaffold.

**Step 1: Locate the end of SKILL_TEMPLATE in `init_skill.py`**

Find the closing `"""` of `SKILL_TEMPLATE`. The last real content line before it will be something like `[TODO: Add content here...]`.

**Step 2: Add the four mandatory sections before the closing `"""`**

In `init_skill.py`, find the end of `SKILL_TEMPLATE` and add:

````
## Implementation Patterns

[TODO: Provide working code examples — not prose. Show the actual implementation, not "use library X".]

```python
# Example: minimal working pattern
````

## Failure Modes & Edge Cases

[TODO: Cover at least 3 concrete failure scenarios. What breaks? Race conditions? Null inputs? Timeouts?]

| Scenario                 | What Happens           | How to Handle                           |
| ------------------------ | ---------------------- | --------------------------------------- |
| [e.g. API timeout]       | [e.g. request hangs]   | [e.g. set timeout + retry with backoff] |
| [e.g. concurrent writes] | [e.g. data corruption] | [e.g. use optimistic locking]           |
| [e.g. null input]        | [e.g. silent failure]  | [e.g. validate at boundary]             |

## Decision Matrix

[TODO: When should they use X vs Y? Don't just list options — give a recommendation and explain why.]

| Situation                            | Recommended Approach | Why                                       |
| ------------------------------------ | -------------------- | ----------------------------------------- |
| [e.g. < 10k users, simple data]      | [e.g. Option A]      | [e.g. lower ops burden, sufficient scale] |
| [e.g. > 100k users, complex queries] | [e.g. Option B]      | [e.g. horizontal scaling, index support]  |

## Version Context

[TODO: List key library versions this skill was last verified against. Flag known breaking changes.]

| Library / Framework | Last Verified Version | Notes                                                              |
| ------------------- | --------------------- | ------------------------------------------------------------------ |
| [e.g. Next.js]      | [e.g. 15.x]           | [e.g. App Router only; Pages Router differs]                       |
| [e.g. @auth/core]   | [e.g. 0.37.x]         | [e.g. Breaking change in 0.35: session callback signature changed] |

````

**Step 3: Run existing tests to confirm nothing broke**

```bash
pnpm test
````

Expected: 13 passed (2 test files)

**Step 4: Commit**

```bash
git add .agent/skills/skill-creator/scripts/init_skill.py
git commit -m "feat(skill-quality): add four mandatory depth sections to SKILL.md template"
```

---

## Task 3: Update INDEX.md with new skill

**Files:**

- Modify: `.agent/skills/INDEX.md`

**Step 1: Add skill-depth-standard to the INDEX**

Open `.agent/skills/INDEX.md` and add an entry for `skill-depth-standard` in the Methodology section (alphabetical order within the section):

```
| **Methodology** | `skill-depth-standard` | Rubric and checklist for auditing and writing deep skills |
```

**Step 2: Validate INDEX.md references the correct path**

```bash
ls .agent/skills/skill-depth-standard/SKILL.md
```

Expected: file exists

**Step 3: Commit**

```bash
git add .agent/skills/INDEX.md
git commit -m "docs(skill-quality): add skill-depth-standard to INDEX.md"
```

---

## Task 4: Build Auth skill (Reference Implementation)

**Files:**

- Create: `.agent/skills/auth-systems/SKILL.md`
- Create: `.agent/skills/auth-systems/references/clerk-patterns.md`
- Create: `.agent/skills/auth-systems/references/authjs-patterns.md`

This is the gold-standard reference skill — build it with full depth across all four mandatory sections.

**Step 1: Create the main SKILL.md**

````markdown
---
name: auth-systems
description: Use when implementing authentication in web applications. Covers Clerk (managed auth) and Auth.js/NextAuth (self-hosted) with session handling, protected routes, OAuth providers, and edge cases including concurrent session handling, token refresh races, and middleware configuration.
---

# Auth Systems

> **Reference skill** — built to the `skill-depth-standard`. See `references/clerk-patterns.md` for Clerk-specific patterns and `references/authjs-patterns.md` for Auth.js/NextAuth patterns.

## Decision Matrix

**Choose Clerk when:**

- You want managed auth with zero infrastructure: Clerk handles token storage, rotation, and session sync
- Your app needs pre-built UI components (sign-in, user profile, org switcher) out of the box
- You're building a multi-tenant SaaS with org/workspace isolation — Clerk's org model maps directly

**Choose Auth.js (NextAuth) when:**

- You need to self-host and own your session data (compliance, cost at scale, custom storage)
- You're integrating with an existing database user table via a custom adapter
- Clerk's pricing model doesn't fit your user volume

**Default recommendation:** Start with Clerk for new projects. Switch to Auth.js when you hit Clerk's pricing ceiling or need full database control.

| Situation                                 | Choice  | Why                                          |
| ----------------------------------------- | ------- | -------------------------------------------- |
| New SaaS, < 10k MAU                       | Clerk   | Zero infra, fast to ship, generous free tier |
| Compliance requirement (own session data) | Auth.js | Full control, no third-party session storage |
| Custom database adapter needed            | Auth.js | Clerk doesn't support custom adapters        |
| Multi-tenant with orgs out-of-box         | Clerk   | Native org model, no custom code             |
| > 100k MAU, cost-sensitive                | Auth.js | Clerk pricing scales with users              |

## Implementation Patterns

See `references/clerk-patterns.md` for Clerk implementation and `references/authjs-patterns.md` for Auth.js.

**Middleware (Next.js App Router) — applies to both:**

```typescript
// middleware.ts — run on every request, protect routes
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const isPublicRoute = createRouteMatcher([
  "/sign-in(.*)",
  "/sign-up(.*)",
  "/api/webhooks(.*)",
]);

export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) {
    await auth.protect(); // redirects to sign-in if unauthenticated
  }
});

export const config = {
  matcher: [
    "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    "/(api|trpc)(.*)",
  ],
};
```
````

## Failure Modes & Edge Cases

| Scenario                                | What Happens                                                     | How to Handle                                                                                  |
| --------------------------------------- | ---------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| Token refresh race (two tabs)           | Both tabs attempt refresh simultaneously, one gets a stale token | Auth.js: use database sessions (not JWT) to avoid race. Clerk: handled automatically.          |
| Concurrent session on new device        | User logs in on phone while laptop session is active             | Clerk: configurable session limit. Auth.js: query `sessions` table and invalidate oldest.      |
| OAuth provider returns unexpected scope | Callback fails silently if required scope is missing             | Validate `account.scope` in the `signIn` callback; return `false` to reject                    |
| Middleware misconfiguration             | Protected routes accessible without auth                         | Test with `curl -H "Cookie: " <protected-url>` — should redirect to sign-in                    |
| JWT secret rotation                     | Existing sessions invalid after secret change                    | Never rotate secret without a grace period; Auth.js supports `secret` as an array for rollover |
| Webhook replay attack                   | Clerk webhook processed twice                                    | Store `webhookId` and reject duplicates; verify `svix-timestamp` within 5 minutes              |

## Version Context

| Library                    | Last Verified    | Notes                                                                        |
| -------------------------- | ---------------- | ---------------------------------------------------------------------------- |
| `@clerk/nextjs`            | 6.x              | `clerkMiddleware` replaces `authMiddleware` (deprecated in 5.x)              |
| `next-auth` / `@auth/core` | 5.x (Auth.js v5) | Breaking change from v4: config moves to `auth.ts`, no more `pages/api/auth` |
| `@auth/prisma-adapter`     | 2.x              | Requires Prisma 5.x; session/account table schema changed from v1            |
| Next.js                    | 15.x             | App Router; Pages Router auth pattern differs significantly                  |

````

**Step 2: Create `references/clerk-patterns.md`**

```markdown
# Clerk Patterns

## Server-Side Auth (App Router)

```typescript
import { auth, currentUser } from '@clerk/nextjs/server';

// In a Server Component or Route Handler
export async function GET() {
  const { userId, orgId } = await auth();
  if (!userId) return new Response('Unauthorized', { status: 401 });

  const user = await currentUser(); // full user object (extra network call)
  return Response.json({ userId, orgId });
}
````

## Client-Side Auth

```typescript
'use client';
import { useAuth, useUser, useOrganization } from '@clerk/nextjs';

export function Dashboard() {
  const { userId, isLoaded } = useAuth();
  const { user } = useUser();
  const { organization } = useOrganization();

  if (!isLoaded) return null; // always handle loading state
  if (!userId) return <SignIn />;

  return <div>Hello {user?.firstName} — org: {organization?.name}</div>;
}
```

## Webhook Setup (Clerk → your database)

```typescript
// app/api/webhooks/clerk/route.ts
import { Webhook } from "svix";
import { headers } from "next/headers";
import { WebhookEvent } from "@clerk/nextjs/server";

export async function POST(req: Request) {
  const WEBHOOK_SECRET = process.env.CLERK_WEBHOOK_SECRET;
  const headerPayload = await headers();
  const svix_id = headerPayload.get("svix-id");
  const svix_timestamp = headerPayload.get("svix-timestamp");
  const svix_signature = headerPayload.get("svix-signature");

  const body = await req.text();
  const wh = new Webhook(WEBHOOK_SECRET!);

  let event: WebhookEvent;
  try {
    event = wh.verify(body, {
      "svix-id": svix_id!,
      "svix-timestamp": svix_timestamp!,
      "svix-signature": svix_signature!,
    }) as WebhookEvent;
  } catch {
    return new Response("Invalid signature", { status: 400 });
  }

  if (event.type === "user.created") {
    await db.user.create({
      data: {
        clerkId: event.data.id,
        email: event.data.email_addresses[0].email_address,
      },
    });
  }

  return new Response("OK");
}
```

````

**Step 3: Create `references/authjs-patterns.md`**

```markdown
# Auth.js (NextAuth v5) Patterns

## Setup

```typescript
// auth.ts — single source of truth
import NextAuth from 'next-auth';
import GitHub from 'next-auth/providers/github';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { db } from '@/lib/db';

export const { handlers, signIn, signOut, auth } = NextAuth({
  adapter: PrismaAdapter(db),
  providers: [GitHub],
  callbacks: {
    session({ session, user }) {
      session.user.id = user.id; // expose DB user id to client
      return session;
    },
  },
});
````

```typescript
// app/api/auth/[...nextauth]/route.ts
import { handlers } from "@/auth";
export const { GET, POST } = handlers;
```

## Server-Side Session

```typescript
import { auth } from '@/auth';

// Server Component
export default async function Page() {
  const session = await auth();
  if (!session) redirect('/sign-in');
  return <div>Hello {session.user.name}</div>;
}
```

## Database Schema (Prisma)

```prisma
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
```

````

**Step 4: Validate**

```bash
python .agent/skills/skill-creator/scripts/quick_validate.py .agent/skills/auth-systems
````

Expected: `Skill is valid!`

**Step 5: Commit**

```bash
git add .agent/skills/auth-systems/
git commit -m "feat(skill-quality): add auth-systems reference skill (Clerk + Auth.js)"
```

---

## Task 5: Build Stripe payments skill

**Files:**

- Create: `.agent/skills/stripe-payments/SKILL.md`
- Create: `.agent/skills/stripe-payments/references/webhook-patterns.md`
- Create: `.agent/skills/stripe-payments/references/subscription-patterns.md`

Follow the same four-section structure as the Auth reference skill. Cover:

**Decision Matrix:** Stripe Checkout (hosted) vs. Stripe Elements (custom UI) vs. Payment Intents API (full control). Recommend Checkout for most cases.

**Implementation Patterns:**

- Checkout Session creation (server-side) with `success_url` and metadata
- Customer Portal for self-serve billing management
- `stripe.webhooks.constructEvent()` for verified webhook handling

**Failure Modes & Edge Cases:**

- Webhook duplicate delivery — use idempotency keys and store `stripeEventId`
- Payment failure mid-subscription — `invoice.payment_failed` event, grace period logic
- Customer switches plan mid-cycle — proration handling, `proration_behavior: 'create_prorations'`
- Webhook signature verification failure — wrong secret (test vs. live), clock skew

**Version Context:** `stripe` npm SDK 17.x, Stripe API version `2025-01-27.acacia`.

**Step 1: Create SKILL.md, references/webhook-patterns.md, references/subscription-patterns.md** following the auth-systems structure.

**Step 2: Validate**

```bash
python .agent/skills/skill-creator/scripts/quick_validate.py .agent/skills/stripe-payments
```

Expected: `Skill is valid!`

**Step 3: Commit**

```bash
git add .agent/skills/stripe-payments/
git commit -m "feat(skill-quality): add stripe-payments skill (checkout, subscriptions, webhooks)"
```

---

## Task 6: Build RAG / vector search skill

**Files:**

- Create: `.agent/skills/rag-vector-search/SKILL.md`
- Create: `.agent/skills/rag-vector-search/references/embedding-pipelines.md`
- Create: `.agent/skills/rag-vector-search/references/retrieval-patterns.md`

**Decision Matrix:** pgvector (already have Postgres, < 1M vectors) vs. Pinecone (managed, > 1M vectors or cross-region) vs. Qdrant (self-hosted, advanced filtering). Recommend pgvector for most new projects.

**Implementation Patterns:**

- Embedding pipeline: chunk → embed via OpenAI `text-embedding-3-small` → upsert to vector store
- Hybrid search: vector similarity + keyword filter (`tsvector`) for better precision
- pgvector: `CREATE EXTENSION vector`, `<=>` cosine distance operator, `ivfflat` index

**Failure Modes & Edge Cases:**

- Chunk boundary splits context — use overlapping chunks (stride = 50% of chunk size)
- Embedding model changes invalidate existing vectors — version-tag your embeddings
- Top-k returns irrelevant results — add a similarity threshold (`score > 0.75`)
- Cold start (empty index) — seed with synthetic examples or disable RAG until threshold reached

**Version Context:** `pgvector` 0.8.x, `openai` SDK 4.x, `text-embedding-3-small` (1536 dims).

**Steps:** Same pattern as Tasks 4–5. Validate + commit.

```bash
git add .agent/skills/rag-vector-search/
git commit -m "feat(skill-quality): add rag-vector-search skill (embeddings, pgvector, retrieval)"
```

---

## Task 7: Build Agent Architecture skill

**Files:**

- Create: `.agent/skills/agent-architecture/SKILL.md`
- Create: `.agent/skills/agent-architecture/references/multi-agent-patterns.md`
- Create: `.agent/skills/agent-architecture/references/memory-orchestration.md`

**Decision Matrix:** Single agent with tools vs. orchestrator + subagents vs. event-driven pipeline. Recommend single agent for tasks that fit in one context window; orchestrator pattern when tasks exceed context or need parallelism.

**Implementation Patterns:**

- Tool definition (JSON Schema) and result parsing
- Orchestrator dispatch pattern: parse task → select agent profile → handoff with context summary
- Memory types: in-context (ephemeral), external (vector DB), structured (key-value store)

**Failure Modes & Edge Cases:**

- Agent loop (tool calls tool that calls original tool) — add call depth counter, max 10
- Context overflow mid-task — checkpoint state to external store before summarizing
- Handoff information loss — always include full task context in handoff, not just delta
- Parallel agents conflict on shared resource — use optimistic locking or queue serialization

**Version Context:** Anthropic SDK 0.37.x, OpenAI SDK 4.x, tool_use API (Claude) / function_calling (OpenAI).

**Steps:** Same pattern. Validate + commit.

```bash
git add .agent/skills/agent-architecture/
git commit -m "feat(skill-quality): add agent-architecture skill (multi-agent, memory, orchestration)"
```

---

## Task 8: Build Prompt Engineering skill

**Files:**

- Create: `.agent/skills/prompt-engineering/SKILL.md`
- Create: `.agent/skills/prompt-engineering/references/evaluation-workflows.md`
- Create: `.agent/skills/prompt-engineering/references/anti-patterns.md`

**Decision Matrix:** Zero-shot vs. few-shot vs. chain-of-thought vs. tool use. When to use system prompt vs. user turn for instructions. Structured output (JSON mode) vs. free-form.

**Implementation Patterns:**

- Prompt template structure: role → context → task → constraints → output format
- Few-shot example selection: diverse, representative, edge-inclusive
- Eval loop: prompt → sample N outputs → score with rubric → iterate

**Failure Modes & Edge Cases:**

- Prompt injection via user input — never concatenate user input directly into system prompt
- Instruction drift in long conversations — re-inject key constraints every N turns
- Hallucination on structured output — always validate JSON output against schema, retry once on parse failure
- Temperature sensitivity — deterministic tasks use temp=0; creative tasks use temp=0.7-1.0

**Version Context:** Claude claude-sonnet-4-6 / claude-opus-4-6, GPT-4o (`2025-01-01-preview`). Prompt formats differ by model family.

**Steps:** Same pattern. Validate + commit.

```bash
git add .agent/skills/prompt-engineering/
git commit -m "feat(skill-quality): add prompt-engineering skill (templates, evaluation, anti-patterns)"
```

---

## Task 9: Update INDEX.md and run full test suite

**Files:**

- Modify: `.agent/skills/INDEX.md`

**Step 1: Add all 5 new skills to INDEX.md**

Add entries in the appropriate category rows:

```
| **Auth**     | `auth-systems`       | Clerk and Auth.js/NextAuth — sessions, OAuth, protected routes |
| **Payments** | `stripe-payments`    | Checkout, subscriptions, webhooks, billing patterns           |
| **AI/LLM**   | `rag-vector-search`  | Embedding pipelines, pgvector/Pinecone, retrieval patterns    |
| **AI/LLM**   | `agent-architecture` | Multi-agent systems, memory, handoffs, orchestration          |
| **AI/LLM**   | `prompt-engineering` | Templates, evaluation loops, anti-patterns                    |
```

**Step 2: Run full test suite**

```bash
pnpm test
```

Expected: 13 passed (2 test files), 0 failures

**Step 3: Validate all new skills**

```bash
for skill in auth-systems stripe-payments rag-vector-search agent-architecture prompt-engineering skill-depth-standard; do
  echo -n "$skill: "
  python .agent/skills/skill-creator/scripts/quick_validate.py ".agent/skills/$skill"
done
```

Expected: `Skill is valid!` for each

**Step 4: Final commit**

```bash
git add .agent/skills/INDEX.md
git commit -m "docs(skill-quality): update INDEX.md with all v1.2 skills"
```
