---
phase: 05-ci-and-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - .nvmrc
  - .github/workflows/ci.yml
autonomous: false
requirements:
  - CI-01
  - CI-02
  - CI-03

must_haves:
  truths:
    - "A push to main or an opened PR triggers the GitHub Actions CI workflow automatically"
    - "The pipeline runs install → lint → type-check → test → build in sequence and fails fast on any step failure"
    - "The main branch requires the CI status check to pass before any PR can be merged"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "GitHub Actions CI pipeline definition"
      contains: "on: push|pull_request"
    - path: "package.json"
      provides: "Root workspace package.json with lint, type-check, test, build scripts"
      exports: ["lint", "type-check", "test", "build"]
    - path: ".nvmrc"
      provides: "Node version pin for consistency across environments"
      contains: "20"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "package.json scripts"
      via: "pnpm run lint, pnpm run type-check, pnpm run test, pnpm run build"
      pattern: "pnpm run (lint|type-check|test|build)"
    - from: "GitHub branch protection rule"
      to: ".github/workflows/ci.yml"
      via: "required status check name matching workflow job id"
      pattern: "ci / build"
---

<objective>
Set up the GitHub Actions CI pipeline and enforce it via branch protection on main.

Purpose: Give the viflo repo automated quality gates — every push and PR runs lint, type-check, test, and build. Branch protection ensures a failing pipeline blocks merge, closing CI-01, CI-02, and CI-03.
Output: `.github/workflows/ci.yml`, root `package.json` with workspace scripts, `.nvmrc`, and branch protection active on main.
</objective>

<execution_context>
@/home/ollie/.claude/get-shit-done/workflows/execute-plan.md
@/home/ollie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ci-and-security/05-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create root package.json and .nvmrc</name>
  <files>package.json, .nvmrc</files>
  <action>
    Create a root `package.json` at the repo root. This is a documentation/tooling monorepo — there is no application to build in the traditional sense. The CI scripts must still be runnable and meaningful:

    - `lint`: Run prettier check across all markdown, YAML, and JSON files. Command: `prettier --check "**/*.{md,yaml,yml,json}" --ignore-path .gitignore`
    - `type-check`: Run TypeScript compiler on the packages directory. Command: `tsc --noEmit --project packages/tsconfig/tsconfig.json` (if a tsconfig exists there) or simply `echo "type-check: no TS sources at root" && exit 0` if no tsconfig is present at root. Check first: if `packages/tsconfig/` has a `tsconfig.json` that covers source files, use it; otherwise emit a no-op that exits 0.
    - `test`: Run `node scripts/verify_env.py` via `python3 scripts/verify_env.py --ci` or if that script doesn't accept `--ci`, just `python3 scripts/verify_env.py`. If the script exits non-zero due to missing optional API keys, adjust to exit 0 for environment-variable-optional paths. Alternatively, if the verify script would fail in CI due to missing keys, use `echo "tests: no test suite yet (Phase 6)" && exit 0` as a placeholder that CI can run. Check `scripts/verify_env.py` first to understand its exit behavior before deciding.
    - `build`: `echo "build: documentation repo — no build step" && exit 0`

    The key constraint: every script MUST exit 0 in a clean CI environment without secrets. Phase 6 will replace the `test` placeholder with a real Vitest suite.

    Also create `.nvmrc` containing just `20` (Node 20 LTS).

    package.json should include:
    - `"private": true`
    - `"engines": { "node": ">=20.0.0", "pnpm": ">=10.0.0" }`
    - `"packageManager": "pnpm@10.0.0"` (or latest stable — check `pnpm-lock.yaml` header for actual version used)
    - `"scripts"` with the four commands above
    - No dependencies (this is a meta/tooling root)
  </action>
  <verify>
    <automated>cd /home/ollie/Development/Tools/viflo && node -e "const p = require('./package.json'); const scripts = Object.keys(p.scripts); ['lint','type-check','test','build'].forEach(s => { if (!scripts.includes(s)) throw new Error('Missing script: ' + s); }); console.log('package.json OK:', scripts)"</automated>
    <manual>Confirm .nvmrc contains "20" and package.json has all four scripts</manual>
  </verify>
  <done>package.json exists with lint, type-check, test, build scripts that each exit 0 in a clean environment. .nvmrc contains "20".</done>
</task>

<task type="auto">
  <name>Task 2: Create GitHub Actions CI workflow</name>
  <files>.github/workflows/ci.yml</files>
  <action>
    Create `.github/workflows/ci.yml` with a single job `build` containing sequential steps. Use a single job (not multiple parallel jobs) per the user decision: "single job with sequential steps: install → lint → type-check → test → build" and "fails fast when any step fails (GitHub Actions default)".

    Workflow spec:
    - `name: CI`
    - Triggers: `on: push: branches: [main]` and `on: pull_request` (all branches)
    - Single job named `build` running on `ubuntu-latest`
    - Steps:
      1. `actions/checkout@v4`
      2. `actions/setup-node@v4` with `node-version-file: .nvmrc` and `cache: pnpm` — this enables automatic pnpm store caching
      3. Install pnpm: `npm install -g pnpm` or use `actions/setup-node` pnpm cache approach. Better: use `pnpm/action-setup@v4` before `actions/setup-node` to ensure pnpm is available. Set `pnpm/action-setup@v4` with `version: latest` (or pin to `v4`).
      4. Run `pnpm install --frozen-lockfile`
      5. Run `pnpm run lint`
      6. Run `pnpm run type-check`
      7. Run `pnpm run test`
      8. Run `pnpm run build`

    Pin all action versions:
    - `actions/checkout@v4`
    - `pnpm/action-setup@v4`
    - `actions/setup-node@v4`

    The job id must be `build` (this is what branch protection will reference as the required status check).

    Do NOT add deployment steps, coverage upload, or artifact upload — keep it minimal and focused on quality gates.
  </action>
  <verify>
    <automated>cd /home/ollie/Development/Tools/viflo && python3 -c "import yaml; wf = yaml.safe_load(open('.github/workflows/ci.yml')); job = wf['jobs']['build']; steps = [s.get('run','') for s in job['steps']]; cmds = ' '.join(steps); assert 'pnpm install' in cmds, 'missing install'; assert 'pnpm run lint' in cmds, 'missing lint'; assert 'pnpm run type-check' in cmds, 'missing type-check'; assert 'pnpm run test' in cmds, 'missing test'; assert 'pnpm run build' in cmds, 'missing build'; print('Workflow steps OK')"</automated>
    <manual>Open .github/workflows/ci.yml and confirm triggers, single job named "build", sequential steps, pinned action versions</manual>
  </verify>
  <done>.github/workflows/ci.yml exists with on: [push/pull_request], single "build" job, sequential install→lint→type-check→test→build steps, pinned action versions.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify CI run passes and enable branch protection on main</name>
  <files>none — this task verifies GitHub state, not local files</files>
  <action>
    Before prompting for human verification, attempt to set branch protection automatically:
    ```bash
    REPO=$(git remote get-url origin | sed 's|.*github.com[:/]\(.*\)\.git|\1|' | sed 's|.*github.com[:/]\(.*\)|\1|')
    gh api repos/$REPO/branches/main/protection \
      --method PUT \
      --input - <<EOF
    {
      "required_status_checks": {"strict": true, "contexts": ["build"]},
      "enforce_admins": false,
      "required_pull_request_reviews": null,
      "restrictions": null
    }
    EOF
    ```
    If this succeeds, note "branch protection set via gh CLI" in the summary.
    If it fails due to auth or permissions, the human-verify step below will handle it manually.
  </action>
  <verify>
    <automated>gh api repos/$(git remote get-url origin | sed 's|.*github.com[:/]\(.*\)\.git|\1|' | sed 's|.*github.com[:/]\(.*\)|\1|')/branches/main/protection 2>/dev/null | python3 -c "import json,sys; p=json.load(sys.stdin); print('Branch protection active:', p.get('required_status_checks',{}).get('contexts',[]))" || echo "Branch protection check requires manual verification"</automated>
    <manual>Visit GitHub Actions tab and confirm CI run passes; confirm branch protection on main requires "build" status check</manual>
  </verify>
  <done>GitHub Actions CI workflow has at least one successful run. Branch protection on main requires the "build" status check to pass before merging.</done>
  <what-built>Root package.json with CI scripts, .nvmrc, and .github/workflows/ci.yml have been committed and pushed to GitHub. The workflow should trigger automatically on the push.</what-built>
  <how-to-verify>
    1. Push the branch to GitHub (if not already on main, open a PR)
    2. Visit the repository's Actions tab: https://github.com/[owner]/viflo/actions
    3. Confirm a workflow run named "CI" appears and all steps pass (green)
    4. If gh CLI branch protection command above failed, enable it manually:
       GitHub → Settings → Branches → Add branch protection rule → Branch name: main → Check "Require status checks to pass before merging" → Select "build" → Save.
    5. Confirm branch protection is active: a PR with a failing check shows merge blocked.
  </how-to-verify>
  <resume-signal>Type "approved" when the CI run passes and branch protection is active on main, or describe any issues encountered.</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `.github/workflows/ci.yml` exists and is valid YAML: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml')); print('valid')"`
2. `package.json` exists with all four scripts: `node -e "const p=require('./package.json'); console.log(Object.keys(p.scripts))"`
3. `.nvmrc` exists and contains "20": `cat .nvmrc`
4. GitHub Actions tab shows a successful CI run
5. Branch protection is active on main (verified via checkpoint)
</verification>

<success_criteria>
- CI-01: A push or opened PR triggers the GitHub Actions workflow automatically
- CI-02: Pipeline runs install → lint → type-check → test → build in sequence with fail-fast behavior
- CI-03: A PR with a failing pipeline step cannot be merged (branch protection enforces it)
</success_criteria>

<output>
After completion, create `.planning/phases/05-ci-and-security/05-01-SUMMARY.md` documenting:
- Files created (package.json, .nvmrc, .github/workflows/ci.yml)
- Exact CI script commands used
- Workflow job ID used for branch protection ("build")
- Branch protection settings applied
- Any decisions made (e.g., pnpm caching approach, placeholder scripts)
</output>
