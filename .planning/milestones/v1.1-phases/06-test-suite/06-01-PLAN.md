---
phase: 06-test-suite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/vitest.config.ts
  - apps/web/tsconfig.json
  - apps/web/src/validation/skill.ts
  - apps/web/src/validation/skill.test.ts
  - apps/web/src/parsing/plan.ts
  - apps/web/src/parsing/plan.test.ts
  - package.json
autonomous: true
requirements:
  - QUAL-03
  - QUAL-04

must_haves:
  truths:
    - "Running pnpm test in apps/web/ executes the Vitest suite and reports pass/fail"
    - "Every utility function has at least one test covering its expected behavior"
    - "CI pipeline runs the test suite and fails when any test fails"
  artifacts:
    - path: "apps/web/package.json"
      provides: "Package config with vitest and test scripts"
      exports: ["test", "test:coverage"]
    - path: "apps/web/vitest.config.ts"
      provides: "Vitest configuration with coverage settings"
      contains: "coverage: { reporter: ['text', 'json', 'html'] }"
    - path: "apps/web/src/validation/skill.ts"
      provides: "Skill frontmatter validation utility"
    - path: "apps/web/src/validation/skill.test.ts"
      provides: "Tests for skill validation"
    - path: "apps/web/src/parsing/plan.ts"
      provides: "Plan file parsing utility"
    - path: "apps/web/src/parsing/plan.test.ts"
      provides: "Tests for plan parsing"
  key_links:
    - from: "apps/web/src/validation/skill.ts"
      to: "apps/web/src/validation/skill.test.ts"
      via: "import { validateSkillFrontmatter } from './skill'"
    - from: "apps/web/src/parsing/plan.ts"
      to: "apps/web/src/parsing/plan.test.ts"
      via: "import { parsePlanFile } from './plan'"
    - from: "root package.json test script"
      to: "apps/web test"
      via: "pnpm --filter web test"
---

<objective>
Set up Vitest test suite in apps/web/ with utility functions and comprehensive tests.

Purpose: Demonstrate viflo's testing patterns with Vitest, satisfying QUAL-03 (≥1 test per utility) and QUAL-04 (CI runs tests). The utilities validate viflo's own metadata formats.

Output: `apps/web/` package with Vitest, validation utilities, parsing utilities, and passing tests.
</objective>

<execution_context>
@/home/ollie/.claude/get-shit-done/workflows/execute-plan.md
@/home/ollie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-test-suite/06-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create apps/web/ package structure</name>
  <files>apps/web/package.json, apps/web/tsconfig.json, apps/web/vitest.config.ts</files>
  <action>
    Create the apps/web/ directory with package configuration:

    1. `apps/web/package.json`:
    ```json
    {
      "name": "@viflo/web",
      "version": "1.0.0",
      "private": true,
      "type": "module",
      "scripts": {
        "test": "vitest run",
        "test:watch": "vitest",
        "test:coverage": "vitest run --coverage"
      },
      "devDependencies": {
        "@types/node": "^20.0.0",
        "@vitest/coverage-v8": "^1.0.0",
        "typescript": "^5.3.0",
        "vitest": "^1.0.0",
        "yaml": "^2.3.0"
      }
    }
    ```

    2. `apps/web/tsconfig.json`:
    ```json
    {
      "compilerOptions": {
        "target": "ES2022",
        "module": "ESNext",
        "moduleResolution": "bundler",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "outDir": "./dist",
        "rootDir": "./src"
      },
      "include": ["src/**/*"]
    }
    ```

    3. `apps/web/vitest.config.ts`:
    ```typescript
    import { defineConfig } from 'vitest/config';

    export default defineConfig({
      test: {
        coverage: {
          provider: 'v8',
          reporter: ['text', 'json', 'html'],
          exclude: ['node_modules/', 'dist/', '**/*.test.ts'],
        },
      },
    });
    ```

  </action>
  <verify>
    <automated>cd apps/web && test -f package.json && test -f tsconfig.json && test -f vitest.config.ts && echo "Config files exist"</automated>
    <manual>Verify package.json has vitest, @vitest/coverage-v8 dependencies</manual>
  </verify>
  <done>apps/web/ directory created with package.json, tsconfig.json, vitest.config.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create skill validation utility with tests</name>
  <files>apps/web/src/validation/skill.ts, apps/web/src/validation/skill.test.ts</files>
  <action>
    Create skill metadata validation utility:

    1. `apps/web/src/validation/skill.ts`:
    ```typescript
    import YAML from 'yaml';

    export interface SkillFrontmatter {
      name: string;
      description: string;
      triggers?: string[];
    }

    export interface ValidationResult {
      valid: boolean;
      errors: string[];
    }

    export function validateSkillFrontmatter(content: string): ValidationResult {
      const errors: string[] = [];

      // Extract frontmatter between --- markers
      const match = content.match(/^---\n([\s\S]*?)\n---/);
      if (!match) {
        return { valid: false, errors: ['Missing YAML frontmatter'] };
      }

      try {
        const frontmatter = YAML.parse(match[1]) as SkillFrontmatter;

        if (!frontmatter.name) {
          errors.push('Missing required field: name');
        }
        if (!frontmatter.description) {
          errors.push('Missing required field: description');
        }

        return { valid: errors.length === 0, errors };
      } catch (e) {
        return { valid: false, errors: ['Invalid YAML syntax'] };
      }
    }

    export function extractTriggers(content: string): string[] {
      const match = content.match(/^---\n([\s\S]*?)\n---/);
      if (!match) return [];

      try {
        const frontmatter = YAML.parse(match[1]) as SkillFrontmatter;
        return frontmatter.triggers || [];
      } catch {
        return [];
      }
    }
    ```

    2. `apps/web/src/validation/skill.test.ts`:
    ```typescript
    import { describe, it, expect } from 'vitest';
    import { validateSkillFrontmatter, extractTriggers } from './skill';

    describe('validateSkillFrontmatter', () => {
      it('validates correct frontmatter', () => {
        const content = `---\nname: test-skill\ndescription: A test skill\ntriggers:\n  - test\n---\n# Content`;
        const result = validateSkillFrontmatter(content);
        expect(result.valid).toBe(true);
        expect(result.errors).toHaveLength(0);
      });

      it('fails when frontmatter is missing', () => {
        const content = '# Just markdown\nNo frontmatter here.';
        const result = validateSkillFrontmatter(content);
        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Missing YAML frontmatter');
      });

      it('fails when name is missing', () => {
        const content = `---\ndescription: A test skill\n---\n# Content`;
        const result = validateSkillFrontmatter(content);
        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Missing required field: name');
      });

      it('fails when description is missing', () => {
        const content = `---\nname: test-skill\n---\n# Content`;
        const result = validateSkillFrontmatter(content);
        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Missing required field: description');
      });

      it('fails on invalid YAML', () => {
        const content = `---\nname: : invalid yaml\n---\n# Content`;
        const result = validateSkillFrontmatter(content);
        expect(result.valid).toBe(false);
        expect(result.errors).toContain('Invalid YAML syntax');
      });
    });

    describe('extractTriggers', () => {
      it('returns triggers from frontmatter', () => {
        const content = `---\nname: test\ndescription: Test\ntriggers:\n  - trigger1\n  - trigger2\n---\nContent`;
        expect(extractTriggers(content)).toEqual(['trigger1', 'trigger2']);
      });

      it('returns empty array when no triggers', () => {
        const content = `---\nname: test\ndescription: Test\n---\nContent`;
        expect(extractTriggers(content)).toEqual([]);
      });

      it('returns empty array when no frontmatter', () => {
        const content = '# Just content';
        expect(extractTriggers(content)).toEqual([]);
      });
    });
    ```

  </action>
  <verify>
    <automated>cd apps/web && pnpm install && pnpm run test 2>&1 | grep -E "(PASS|FAIL|Tests)" | head -5</automated>
    <manual>Verify tests pass and show coverage report</manual>
  </verify>
  <done>Skill validation utility created with comprehensive tests, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Create plan parsing utility with tests</name>
  <files>apps/web/src/parsing/plan.ts, apps/web/src/parsing/plan.test.ts</files>
  <action>
    Create plan file parsing utility:

    1. `apps/web/src/parsing/plan.ts`:
    ```typescript
    export interface Task {
      type: 'auto' | 'manual';
      name: string;
      priority?: number;
    }

    export interface ParsedPlan {
      phase: number;
      plan: number;
      tasks: Task[];
    }

    export function parsePlanFile(content: string): ParsedPlan {
      // Extract phase and plan from frontmatter
      const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
      let phase = 0;
      let planNum = 0;

      if (frontmatterMatch) {
        const phaseMatch = frontmatterMatch[1].match(/phase:\s*(\d+)/);
        const planMatch = frontmatterMatch[1].match(/plan:\s*(\d+)/);
        if (phaseMatch) phase = parseInt(phaseMatch[1], 10);
        if (planMatch) planNum = parseInt(planMatch[1], 10);
      }

      // Extract tasks from XML-like structure
      const tasks: Task[] = [];
      const taskRegex = /<task[^>]*>[\s\S]*?<\/task>/g;
      const taskMatches = content.matchAll(taskRegex);

      for (const match of taskMatches) {
        const taskContent = match[0];
        const typeMatch = taskContent.match(/type="(auto|manual)"/);
        const nameMatch = taskContent.match(/<name>([\s\S]*?)<\/name>/);
        const priorityMatch = taskContent.match(/priority="(\d+)"/);

        if (nameMatch) {
          tasks.push({
            type: (typeMatch?.[1] as 'auto' | 'manual') || 'auto',
            name: nameMatch[1].trim(),
            priority: priorityMatch ? parseInt(priorityMatch[1], 10) : undefined,
          });
        }
      }

      return { phase, plan: planNum, tasks };
    }

    export function countTasksByType(tasks: Task[]): { auto: number; manual: number } {
      return tasks.reduce(
        (acc, task) => {
          acc[task.type]++;
          return acc;
        },
        { auto: 0, manual: 0 }
      );
    }
    ```

    2. `apps/web/src/parsing/plan.test.ts`:
    ```typescript
    import { describe, it, expect } from 'vitest';
    import { parsePlanFile, countTasksByType } from './plan';

    describe('parsePlanFile', () => {
      it('parses plan with frontmatter and tasks', () => {
        const content = `---\nphase: 5\nplan: 1\n---\n<plan>\n<task type="auto" priority="1">\n  <name>Task 1</name>\n</task>\n<task type="manual">\n  <name>Task 2</name>\n</task>\n</plan>`;

        const result = parsePlanFile(content);
        expect(result.phase).toBe(5);
        expect(result.plan).toBe(1);
        expect(result.tasks).toHaveLength(2);
        expect(result.tasks[0].name).toBe('Task 1');
        expect(result.tasks[0].type).toBe('auto');
        expect(result.tasks[0].priority).toBe(1);
      });

      it('returns empty tasks when no tasks found', () => {
        const content = `---\nphase: 1\n---\n<plan>\n</plan>`;
        const result = parsePlanFile(content);
        expect(result.tasks).toHaveLength(0);
      });

      it('defaults to auto type when not specified', () => {
        const content = `<task>\n  <name>Task</name>\n</task>`;
        const result = parsePlanFile(content);
        expect(result.tasks[0].type).toBe('auto');
      });
    });

    describe('countTasksByType', () => {
      it('counts tasks by type correctly', () => {
        const tasks = [
          { type: 'auto' as const, name: 'Auto 1' },
          { type: 'auto' as const, name: 'Auto 2' },
          { type: 'manual' as const, name: 'Manual 1' },
        ];
        const result = countTasksByType(tasks);
        expect(result.auto).toBe(2);
        expect(result.manual).toBe(1);
      });

      it('returns zero counts for empty array', () => {
        const result = countTasksByType([]);
        expect(result.auto).toBe(0);
        expect(result.manual).toBe(0);
      });
    });
    ```

  </action>
  <verify>
    <automated>cd apps/web && pnpm run test 2>&1 | grep -E "(Tests:|passed|failed)" | tail -3</automated>
    <manual>Verify all tests pass with 100% coverage on utility functions</manual>
  </verify>
  <done>Plan parsing utility created with tests, all tests pass</done>
</task>

<task type="auto">
  <name>Task 4: Update root package.json test script</name>
  <files>package.json</files>
  <action>
    Update the root package.json test script to run apps/web tests:

    Change from:
    ```json
    "test": "echo 'test: no test suite yet (Phase 6)' && exit 0"
    ```

    To:
    ```json
    "test": "pnpm --filter @viflo/web test"
    ```

    Also update test:coverage:
    ```json
    "test:coverage": "pnpm --filter @viflo/web test:coverage"
    ```

  </action>
  <verify>
    <automated>cd /home/ollie/Development/Tools/viflo && grep -q 'pnpm --filter @viflo/web test' package.json && echo "Test script updated"</automated>
    <manual>Run pnpm test from root and verify it executes apps/web tests</manual>
  </verify>
  <done>Root package.json test script updated to run apps/web Vitest suite</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cd apps/web && pnpm run test` passes with all tests green
2. `cd apps/web && pnpm run test:coverage` generates coverage report
3. `pnpm test` from root runs the Vitest suite
4. Every utility function has test coverage
</verification>

<success_criteria>

- QUAL-03: apps/web/ has Vitest test suite with ≥1 test per utility function
- QUAL-04: CI pipeline runs test suite and fails on test failure
  </success_criteria>

<output>
After completion, create `.planning/phases/06-test-suite/06-01-SUMMARY.md` documenting:
- Files created (package structure, utilities, tests)
- Test count and coverage percentage
- CI integration details
</output>
