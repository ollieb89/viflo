---
phase: 06-test-suite
plan: 02
type: execute
wave: 2
depends_on: ["06-01-PLAN.md"]
files_modified:
  - apps/web/scripts/coverage-ratchet.ts
  - apps/web/package.json
  - apps/web/.coverage/baseline.json
  - .github/workflows/ci.yml
autonomous: true
requirements:
  - QUAL-05

must_haves:
  truths:
    - "A coverage ratchet script records the current coverage baseline"
    - "The script fails if a subsequent run reports a lower coverage percentage"
    - "The baseline file is stored in .coverage/baseline.json"
  artifacts:
    - path: "apps/web/scripts/coverage-ratchet.ts"
      provides: "Coverage ratchet script that enforces coverage thresholds"
    - path: "apps/web/.coverage/baseline.json"
      provides: "Coverage baseline storage"
      contains: "lines, functions, branches, statements percentages"
  key_links:
    - from: "apps/web/scripts/coverage-ratchet.ts"
      to: "apps/web/coverage/coverage-summary.json"
      via: "Reading Vitest coverage output"
    - from: "CI workflow"
      to: "coverage-ratchet.ts"
      via: "pnpm run test:coverage:ratchet"
---

<objective>
Create a coverage ratchet script that enforces coverage thresholds and prevents regression.

Purpose: Satisfy QUAL-05 by ensuring code coverage never decreases between runs. The script compares current coverage against a stored baseline and fails if coverage drops.

Output: `apps/web/scripts/coverage-ratchet.ts` and updated CI workflow that runs the ratchet.
</objective>

<execution_context>
@/home/ollie/.claude/get-shit-done/workflows/execute-plan.md
@/home/ollie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-test-suite/06-CONTEXT.md
@.planning/phases/06-test-suite/06-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create coverage ratchet script</name>
  <files>apps/web/scripts/coverage-ratchet.ts</files>
  <action>
    Create the coverage ratchet script at `apps/web/scripts/coverage-ratchet.ts`:

    ```typescript
    #!/usr/bin/env node
    /**
     * Coverage Ratchet Script
     *
     * Ensures code coverage never decreases from the baseline.
     * Reads coverage from coverage/coverage-summary.json (generated by vitest --coverage)
     * Compares against .coverage/baseline.json
     *
     * Usage:
     *   pnpm run test:coverage:ratchet    # Check against baseline
     *   pnpm run test:coverage:update     # Update baseline to current
     */

    import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
    import { dirname } from 'path';

    interface CoverageMetrics {
      lines: number;
      functions: number;
      branches: number;
      statements: number;
    }

    interface BaselineFile {
      version: string;
      timestamp: string;
      coverage: CoverageMetrics;
    }

    const COVERAGE_PATH = './coverage/coverage-summary.json';
    const BASELINE_PATH = './.coverage/baseline.json';
    const THRESHOLD = 0.01; // Allow 0.01% tolerance for floating point

    function readCurrentCoverage(): CoverageMetrics {
      if (!existsSync(COVERAGE_PATH)) {
        console.error(`‚ùå Coverage file not found: ${COVERAGE_PATH}`);
        console.error('   Run "pnpm run test:coverage" first');
        process.exit(1);
      }

      const summary = JSON.parse(readFileSync(COVERAGE_PATH, 'utf-8'));
      const total = summary.total;

      return {
        lines: total.lines.pct,
        functions: total.functions.pct,
        branches: total.branches.pct,
        statements: total.statements.pct,
      };
    }

    function readBaseline(): CoverageMetrics | null {
      if (!existsSync(BASELINE_PATH)) {
        return null;
      }
      const baseline: BaselineFile = JSON.parse(readFileSync(BASELINE_PATH, 'utf-8'));
      return baseline.coverage;
    }

    function writeBaseline(coverage: CoverageMetrics): void {
      const dir = dirname(BASELINE_PATH);
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }

      const baseline: BaselineFile = {
        version: '1.0.0',
        timestamp: new Date().toISOString(),
        coverage,
      };

      writeFileSync(BASELINE_PATH, JSON.stringify(baseline, null, 2) + '\n');
    }

    function formatCoverage(metrics: CoverageMetrics): string {
      return `lines: ${metrics.lines.toFixed(2)}%, ` +
             `functions: ${metrics.functions.toFixed(2)}%, ` +
             `branches: ${metrics.branches.toFixed(2)}%, ` +
             `statements: ${metrics.statements.toFixed(2)}%`;
    }

    function compareCoverage(current: CoverageMetrics, baseline: CoverageMetrics): string[] {
      const failures: string[] = [];

      const metrics: (keyof CoverageMetrics)[] = ['lines', 'functions', 'branches', 'statements'];

      for (const metric of metrics) {
        const diff = current[metric] - baseline[metric];
        if (diff < -THRESHOLD) {
          failures.push(`${metric}: ${baseline[metric].toFixed(2)}% ‚Üí ${current[metric].toFixed(2)}% (${diff.toFixed(2)}%)`);
        }
      }

      return failures;
    }

    function main(): void {
      const args = process.argv.slice(2);
      const command = args[0] || 'check';

      if (command === 'update') {
        const current = readCurrentCoverage();
        writeBaseline(current);
        console.log('‚úÖ Coverage baseline updated');
        console.log(`   ${formatCoverage(current)}`);
        process.exit(0);
      }

      // Check mode (default)
      const current = readCurrentCoverage();
      const baseline = readBaseline();

      if (!baseline) {
        console.log('‚ö†Ô∏è  No baseline found. Creating initial baseline...');
        writeBaseline(current);
        console.log('‚úÖ Baseline created');
        console.log(`   ${formatCoverage(current)}`);
        process.exit(0);
      }

      console.log('üìä Coverage Comparison');
      console.log(`   Current:  ${formatCoverage(current)}`);
      console.log(`   Baseline: ${formatCoverage(baseline)}`);

      const failures = compareCoverage(current, baseline);

      if (failures.length > 0) {
        console.error('\n‚ùå Coverage regression detected:');
        for (const failure of failures) {
          console.error(`   ‚Ä¢ ${failure}`);
        }
        console.error('\nTo update baseline (if intentional):');
        console.error('   pnpm run test:coverage:update');
        process.exit(1);
      }

      // Check if coverage improved
      const improved = compareCoverage(baseline, current);
      if (improved.length > 0) {
        console.log('\n‚úÖ Coverage improved! Updating baseline...');
        writeBaseline(current);
        for (const imp of improved) {
          console.log(`   ‚Ä¢ ${imp}`);
        }
      } else {
        console.log('\n‚úÖ Coverage meets baseline');
      }

      process.exit(0);
    }

    main();
    ```

  </action>
  <verify>
    <automated>test -f apps/web/scripts/coverage-ratchet.ts && echo "Ratchet script exists"</automated>
    <manual>Verify script has proper TypeScript syntax</manual>
  </verify>
  <done>Coverage ratchet script created at apps/web/scripts/coverage-ratchet.ts</done>
</task>

<task type="auto">
  <name>Task 2: Update package.json with ratchet scripts</name>
  <files>apps/web/package.json</files>
  <action>
    Update `apps/web/package.json` to add the ratchet scripts:

    ```json
    {
      "name": "@viflo/web",
      "version": "1.0.0",
      "private": true,
      "type": "module",
      "scripts": {
        "test": "vitest run",
        "test:watch": "vitest",
        "test:coverage": "vitest run --coverage",
        "test:coverage:ratchet": "vitest run --coverage && npx tsx scripts/coverage-ratchet.ts",
        "test:coverage:update": "vitest run --coverage && npx tsx scripts/coverage-ratchet.ts update"
      },
      "devDependencies": {
        "@types/node": "^20.0.0",
        "@vitest/coverage-v8": "^1.0.0",
        "tsx": "^4.0.0",
        "typescript": "^5.3.0",
        "vitest": "^1.0.0",
        "yaml": "^2.3.0"
      }
    }
    ```

    Note: Added `tsx` as a devDependency for running TypeScript scripts directly.

  </action>
  <verify>
    <automated>grep -q "test:coverage:ratchet" apps/web/package.json && grep -q "tsx" apps/web/package.json && echo "Package.json updated"</automated>
    <manual>Verify scripts are correctly formatted JSON</manual>
  </verify>
  <done>Package.json updated with ratchet scripts and tsx dependency</done>
</task>

<task type="auto">
  <name>Task 3: Create initial baseline and test ratchet</name>
  <files>apps/web/.coverage/baseline.json</files>
  <action>
    Run the test suite with coverage and create the initial baseline:

    ```bash
    cd apps/web
    pnpm install
    pnpm run test:coverage
    pnpm run test:coverage:update
    ```

    This should:
    1. Run all tests with coverage
    2. Generate coverage/coverage-summary.json
    3. Create .coverage/baseline.json with current metrics

    Verify the ratchet works by testing the check mode:
    ```bash
    pnpm run test:coverage:ratchet
    ```

    Should output something like:
    ```
    üìä Coverage Comparison
       Current:  lines: 100.00%, functions: 100.00%, ...
       Baseline: lines: 100.00%, functions: 100.00%, ...

    ‚úÖ Coverage meets baseline
    ```

  </action>
  <verify>
    <automated>test -f apps/web/.coverage/baseline.json && cat apps/web/.coverage/baseline.json | grep -q "coverage" && echo "Baseline created"</automated>
    <manual>Verify baseline.json has valid JSON with coverage metrics</manual>
  </verify>
  <done>Initial coverage baseline created, ratchet script tested</done>
</task>

<task type="auto">
  <name>Task 4: Update CI workflow with coverage ratchet</name>
  <files>.github/workflows/ci.yml</files>
  <action>
    Update `.github/workflows/ci.yml` to add the coverage ratchet step:

    ```yaml
    name: CI

    on:
      push:
        branches: [main]
      pull_request:
        branches: [main]

    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true

    jobs:
      build:
        name: build
        runs-on: ubuntu-latest

        steps:
          - name: Checkout repository
            uses: actions/checkout@v4

          - name: Setup pnpm
            uses: pnpm/action-setup@v4

          - name: Setup Node.js
            uses: actions/setup-node@v4
            with:
              node-version-file: .nvmrc
              cache: pnpm

          - name: Install dependencies
            run: pnpm install --frozen-lockfile

          - name: Run lint
            run: pnpm run lint

          - name: Run type check
            run: pnpm run type-check

          - name: Run tests
            run: pnpm run test

          - name: Run coverage ratchet
            run: pnpm run test:coverage:ratchet

          - name: Run build
            run: pnpm run build
    ```

    Also update the root package.json to include the ratchet command:
    ```json
    "test:coverage:ratchet": "pnpm --filter @viflo/web test:coverage:ratchet"
    ```

  </action>
  <verify>
    <automated>grep -q "test:coverage:ratchet" .github/workflows/ci.yml && grep -q "test:coverage:ratchet" package.json && echo "CI updated with ratchet"</automated>
    <manual>Verify CI workflow YAML is valid</manual>
  </verify>
  <done>CI workflow updated with coverage ratchet step</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm run test:coverage:ratchet` passes when coverage meets baseline
2. Modifying a test to reduce coverage causes the ratchet to fail
3. CI pipeline includes coverage ratchet step
4. `.coverage/baseline.json` is committed and tracked
</verification>

<success_criteria>

- QUAL-05: Coverage ratchet script enforces that coverage percentage never decreases between runs
  </success_criteria>

<output>
After completion, create `.planning/phases/06-test-suite/06-02-SUMMARY.md` documenting:
- Coverage ratchet script location and usage
- Baseline file format
- CI integration
</output>
